# Mesh

The `Mesh` class define the geometry of an object. This geometry is composed of the vertices and indices composed together with a Layout buffer that define how the vertices' array is structured. 

### Variables

The variables and properties of a Mesh object are: 

`std::shared_ptr<VertexArray> _vao`

A shared pointer to a `VertexArray` object, which encapsulates OpenGL vertex array state and buffers. This member manages vertex data on the GPU for rendering.

`std::vector<float> _vertices`

A dynamic array holding vertex attribute data as floating-point numbers. 
Vertices might include position, color, normals, texture coordinates, etc., depending on the vertex layout attached to the `VertexArray` object. 

`uint32_t _numVertices`

Tracks the total number of vertices stored in `_vertices`.

`std::vector<uint32_t> _indices`

An array of indices indicating the order to connect vertices for rendering primitives like triangles. Indexing helps reuse vertices efficiently until the mesh geometry is fully described.

`uint32_t _numIndices`

Tracks the total number of indices stored in `_indices`.


### Mesh custom methods

`void AddVertices(float* vertices, uint32_t numVertices)`

Adds raw vertex data into the mesh.  
Parameters:
- `vertices` - pointer to an array of floats representing vertex attributes.
- `numVertices` - total count of vertices being added.

```
AddVertices(myVertexArray, 100);
```
---
`void AddIndices(uint32_t* indices, uint32_t numIndices)`

Adds index data defining how vertices connect.  
Parameters: 
- `indices` - pointer to an array of indices.
- `numIndices` - number of indices to add.

```
AddIndices(myIndexArray, 150);
```

---
`void Build()`

Processes and uploads the vertex and index data to the `VertexArray` for rendering. This method must be called after all vertices and indices have been added to prepare the mesh for drawing.

---

`void Draw()`

Renders the mesh using currently bound shaders and pipeline states. The method assumes the mesh has been built and buffers are ready on the GPU.

---

`void Bind()`

Binds the mesh's vertex array to the graphics context, preparing it for rendering or further operations.

---
`void Unbind()`

Unbinds any vertex array object, cleaning the state from the graphics pipeline.

### Mesh creation methods

These static factory functions allow quick creation of commonly used 3D shapes:

`static std::shared_ptr<Mesh> CreateBox()`
Returns a shared pointer to a unit-sized box mesh (cube). Useful as a building block for more complex shapes or simple objects.

--- 

`static std::shared_ptr<Mesh> CreateSphere(unsigned int sectorCount = 36, unsigned int stackCount = 18, float radius = 0.5f)`

Generates a sphere mesh with customizable resolution and size.  
Parameters:
- `sectorCount` - Number of vertical sections
- `stackCount` - Number of horizontal sections
- `radius` - Radius of the sphere.

The default parameters produce a smooth sphere of radius 0.5.

---

`static std::shared_ptr<Mesh> CreatePlane()`

Creates a simple flat plane mesh.

### Mesh usage

An example of Mesh usage is: 
```cpp
Mesh mesh0 = Mesh();  
mesh0.AddVertices(vertices, sizeof(vertices) / sizeof(float));  
mesh0.AddIndices(indices, sizeof(indices) / sizeof(uint32_t));  
mesh0.SetLayoutBuffer(  
{  
    {0, DataType::Float3, "aPos"},  
    {1, DataType::Float3, "aNormal"},  
    {2, DataType::Float3, "aColor"},  
    {3, DataType::Float2, "aTexCoord"}  
    });  
mesh0.Build();  
  
mesh0.Draw();  
  
  
// ------------------ DRAW MORE CUBES ---------------------------  
for (int i = 0; i < 6; i++)  
{  
    mainShader->SetMatrix4("uModel", glm::translate(glm::mat4(1.0f), glm::vec3(1.0f + i, 0.0f, -4.0f - i)));  
    mesh0.Draw();  
}
```

As a Mesh only define the geometry, once it has been Built, it can be used as many times as wanted. 

Also, by changing the shader and the materials binded, the look of the object can be changed without changing the geometry used. 

For example, we can modify the "uModel" uniform of the shader that define the model Matrix in order to scale, rotate and translate the same objects: 
```cpp 
for (int i = 0; i < 6; i++)
{
	glm::mat4 scaled_matrix = glm::translate(glm::mat4(1.0f), glm::vec3(1.0f + i, 1.0f, -5.0f - i));
	scaled_matrix = glm::scale(scaled_matrix, glm::vec3(0.3f, 0.3f, 0.3f));
	mainShader->SetMatrix4("uModel", scaled_matrix);
	mesh0.Draw();
}
```

### Why shared_ptr<>

As VertexBuffer (VBO), IndexBuffer(EBO) and VertexArray(VAO) are abstractions or classes to handle the stateful ones generated by OpenGL and stored in its memory, we cannot handle this classes as simple local or relative values. 

As it will cause them to be copied, destroyed in Temporary copies or similar. 

For example: 

If we make this: 
```cpp 
VertexBuffer vbo = VertexBuffer(); 
```

We are creating a temporal VertexBuffer that is then copied to VertexBuffer. At the end of that scope, this temporal is going to be deleted, making the handle of this links between Cometa and OpenGL hard to manage. 

So the best way is to handle in a more controlled lifecycle this variables and a good appointment is using `std::shared_ptr`. This help to share the variables between different executions and delete them when they get out of scope without unintentional copy or deletes. 

### ECS handling

Meshes are contained in MeshRenderable component. 

This allows the MeshRenderable to have direct access to the Mesh that needs to render and also the material that define the visual properties of that Mesh. 

As Mesh is handled as a `std::shared_ptr`, we can share it between different Entities:

```cpp
// World declaration
WorldManagerRef->CreateWorld(0);  
WorldManagerRef->SetCurrentWorld(0);  
std::shared_ptr<World> world0 = WorldManagerRef->GetWorld(0); // World();  
world0->SetCamera(&_camera);  
  
Entity* ent0 = world0->CreateEntity("Entity0");  

  
std::shared_ptr<Material> material0 = std::make_shared<Material>(/*...*/
material0->LoadShader(/*...*/);  
renderable->SetMaterial(material0);  

// Mesh creation
std::shared_ptr<Mesh> mesh0 = std::make_shared<Mesh>();  
mesh0->AddVertices(vertices, sizeof(vertices) / sizeof(float));  
mesh0->AddIndices(indices, sizeof(indices) / sizeof(unsigned int));  
mesh0->SetLayoutBuffer({  
    {0, DataType::Float3, "aPos"},  
    {1, DataType::Float3, "aNormal"},  
    {2, DataType::Float3, "aColor"},  
    {3, DataType::Float2, "aTexCoord"}  
    });  
mesh0->Build();  

renderable->SetMesh(mesh0);  
  
Entity* ent1 = world0->CreateEntity("Entity1");  
MeshRenderable* ent1Renderable = ent1->CreateComponent<MeshRenderable>();    
  
std::shared_ptr<Material> material1 = std::make_shared<Material>(/*...*/);   

ent1Renderable->SetMesh(mesh0);  // Set the same Mesh to entity 1
ent1Renderable->SetMaterial(material1);
```

This allow that Entities can share a common Mesh but the visual is defined by the Material that is attached to its MeshRenderable component. 

### Without using Meshes

You can still being able to render some graphics in a more medium level without using Meshes. 

This involve the creation of VertexBuffer (VBO), IndexBuffer(EBO) and VertexArray(VAO) to control the buffers of OpenGL: 

A good example of this is: 

```cpp
// vertices is a float[] of vertex position, normals, color and texture coordinates
// Indices is uint32_t[] with EBO combination of vertices to generate planes using the vertices. 
    VertexArray vArray0 = VertexArray();

    vArray0.CreateVertexBuffer(vertices, sizeof(vertices));
    vArray0.CreateIndexBuffer(indices, sizeof(indices));

    vArray0.GetVertexBuffers()[0]->SetLayoutBuffer({
            {0, DataType::Float3, "aPos"},
            {1, DataType::Float3, "aNormal"},
            {2, DataType::Float3, "aColor"},
            {3, DataType::Float2, "aTexCoord"}
    });
    vArray0.GetVertexBuffers()[0]->GetLayoutBuffer().Bind();

    _camera.OnUpdate();
    mainShader->SetMatrix4("uViewProjection", _camera.GetViewProyection());
    mainShader->SetFloat3("uViewPos", _camera.GetPosition());                   


    glm::mat4 modelRotated = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -3.0f));
    mainShader->SetMatrix4("uModel", modelRotated);

    vArray0.Bind();


    mainShader->Bind();

    vArray0.Bind();

    glDrawElements(GL_TRIANGLES, sizeof(indices) / sizeof(indices[0]), GL_UNSIGNED_INT, 0);
```